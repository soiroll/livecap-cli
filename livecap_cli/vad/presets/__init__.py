"""Optimized VAD parameter presets (JSON-backed).

Presets are stored as individual JSON files in this package directory
and loaded via ``importlib.resources.files()``.

These presets were generated by Bayesian optimization (Optuna TPE sampler)
using benchmark corpora:
- Japanese (JA): JSUT basic5000 subset
- English (EN): LibriSpeech test-clean subset

See Issue #126 for detailed optimization results.

Usage:
    from livecap_cli.vad.presets import get_optimized_preset, VAD_OPTIMIZED_PRESETS
    from livecap_cli.vad import VADConfig

    # Get preset for specific VAD and language
    preset = get_optimized_preset("silero", "ja")
    if preset:
        vad_config = VADConfig.from_dict(preset["vad_config"])

    # Check available presets
    print(list(VAD_OPTIMIZED_PRESETS.keys()))  # ['silero', 'tenvad', 'webrtc']
"""

from __future__ import annotations

import json
from importlib.resources import files
from typing import Any

__all__ = [
    "VAD_OPTIMIZED_PRESETS",
    "get_optimized_preset",
    "get_available_presets",
    "get_best_vad_for_language",
]

# ---------------------------------------------------------------------------
# Validation
# ---------------------------------------------------------------------------

_SUPPORTED_METRICS = ("cer", "wer")

_REQUIRED_KEYS: dict[str, type | tuple[type, ...]] = {
    "vad_type": str,
    "language": str,
    "vad_config": dict,
    "metadata": dict,
}

_REQUIRED_VAD_CONFIG_KEYS: dict[str, type | tuple[type, ...]] = {
    "min_speech_ms": (int, float),
    "min_silence_ms": (int, float),
    "speech_pad_ms": (int, float),
}

_REQUIRED_METADATA_KEYS: dict[str, type | tuple[type, ...]] = {
    "score": (int, float),
    "metric": str,
    "trials": (int, float),
    "engine": str,
    "created_at": str,
}


def _validate_preset(data: dict[str, Any], source: str) -> None:
    """Validate a preset dictionary against the required schema.

    Args:
        data: Parsed JSON data.
        source: File path or identifier for error messages.

    Raises:
        ValueError: If required keys are missing or have wrong types.
    """
    # Top-level keys
    for key, expected_type in _REQUIRED_KEYS.items():
        if key not in data:
            raise ValueError(
                f"Preset '{source}': missing required key '{key}'. "
                f"Required top-level keys: {list(_REQUIRED_KEYS.keys())}"
            )
        if not isinstance(data[key], expected_type):
            raise ValueError(
                f"Preset '{source}': key '{key}' must be {expected_type.__name__}, "
                f"got {type(data[key]).__name__}"
            )

    # vad_config keys
    vad_config = data["vad_config"]
    for key, expected_type in _REQUIRED_VAD_CONFIG_KEYS.items():
        if key not in vad_config:
            raise ValueError(
                f"Preset '{source}': missing required key 'vad_config.{key}'. "
                f"Required vad_config keys: {list(_REQUIRED_VAD_CONFIG_KEYS.keys())}"
            )
        if not isinstance(vad_config[key], expected_type):
            type_names = (
                expected_type.__name__
                if isinstance(expected_type, type)
                else "/".join(t.__name__ for t in expected_type)
            )
            raise ValueError(
                f"Preset '{source}': key 'vad_config.{key}' must be {type_names}, "
                f"got {type(vad_config[key]).__name__}"
            )

    # metadata keys
    metadata = data["metadata"]
    for key, expected_type in _REQUIRED_METADATA_KEYS.items():
        if key not in metadata:
            raise ValueError(
                f"Preset '{source}': missing required key 'metadata.{key}'. "
                f"Required metadata keys: {list(_REQUIRED_METADATA_KEYS.keys())}"
            )
        if not isinstance(metadata[key], expected_type):
            type_names = (
                expected_type.__name__
                if isinstance(expected_type, type)
                else "/".join(t.__name__ for t in expected_type)
            )
            raise ValueError(
                f"Preset '{source}': key 'metadata.{key}' must be {type_names}, "
                f"got {type(metadata[key]).__name__}"
            )

    # metric value validation
    metric = metadata["metric"]
    if metric not in _SUPPORTED_METRICS:
        raise ValueError(
            f"Preset '{source}': metadata.metric must be one of "
            f"{list(_SUPPORTED_METRICS)}, got '{metric}'"
        )


# ---------------------------------------------------------------------------
# Loading
# ---------------------------------------------------------------------------

def _load_presets() -> dict[str, dict[str, dict[str, Any]]]:
    """Load all preset JSON files from the package directory.

    Returns:
        Nested dict: ``{vad_type: {language: preset_data}}``
        where ``preset_data`` contains ``vad_config``, ``backend``, and ``metadata``.

    Raises:
        ValueError: If any JSON file fails validation.
    """
    package = files(__package__)
    presets: dict[str, dict[str, dict[str, Any]]] = {}

    for resource in package.iterdir():
        if not hasattr(resource, "name") or not resource.name.endswith(".json"):
            continue

        source = resource.name
        raw = resource.read_text(encoding="utf-8")
        data = json.loads(raw)

        _validate_preset(data, source)

        # Ensure backend defaults to {}
        if "backend" not in data:
            data["backend"] = {}

        vad_type = data["vad_type"]
        language = data["language"]

        # Build the preset entry (compatible with old format)
        entry: dict[str, Any] = {
            "vad_config": data["vad_config"],
            "metadata": data["metadata"],
        }
        if data["backend"]:
            entry["backend"] = data["backend"]

        presets.setdefault(vad_type, {})[language] = entry

    return presets


# Module-level cache: loaded once on first import
VAD_OPTIMIZED_PRESETS: dict[str, dict[str, dict[str, Any]]] = _load_presets()


# ---------------------------------------------------------------------------
# Public API (backward-compatible)
# ---------------------------------------------------------------------------

def get_optimized_preset(
    vad_type: str,
    language: str,
) -> dict[str, Any] | None:
    """Get optimized preset for VAD type and language.

    Args:
        vad_type: VAD backend type ("silero", "tenvad", "webrtc")
        language: Language code ("ja", "en")

    Returns:
        Preset dictionary with "vad_config", optional "backend", and "metadata" keys.
        Returns None if no preset exists for the combination.

    Example:
        >>> preset = get_optimized_preset("silero", "ja")
        >>> preset["vad_config"]["threshold"]
        0.294
        >>> preset["metadata"]["score"]
        0.082
    """
    return VAD_OPTIMIZED_PRESETS.get(vad_type, {}).get(language)


def get_available_presets() -> list[tuple[str, str]]:
    """Get list of available (vad_type, language) combinations.

    Returns:
        List of tuples (vad_type, language) for all available presets.

    Example:
        >>> get_available_presets()
        [('silero', 'ja'), ('silero', 'en'), ('tenvad', 'ja'), ...]
    """
    result = []
    for vad_type, languages in VAD_OPTIMIZED_PRESETS.items():
        for language in languages:
            result.append((vad_type, language))
    return result


def get_best_vad_for_language(language: str) -> tuple[str, dict[str, Any]] | None:
    """Get the best performing VAD preset for a language.

    Args:
        language: Language code ("ja", "en")

    Returns:
        Tuple of (vad_type, preset) for the best performing VAD.
        Returns None if no presets exist for the language.

    Example:
        >>> vad_type, preset = get_best_vad_for_language("ja")
        >>> vad_type
        'tenvad'
        >>> preset["metadata"]["score"]
        0.072
    """
    best_vad = None
    best_score = float("inf")

    for vad_type, languages in VAD_OPTIMIZED_PRESETS.items():
        if language in languages:
            preset = languages[language]
            score = preset["metadata"]["score"]
            if score < best_score:
                best_score = score
                best_vad = (vad_type, preset)

    return best_vad
